# HushLink

HushLink is a confidential messaging dapp that keeps message content private while still using on-chain storage and
verification. Each message is encrypted client-side, and the encryption key is protected with Zama FHEVM so only the
intended recipient (and the sender) can decrypt it.

## Table of Contents

- Project Summary
- Problems Solved
- Core Advantages
- How It Works
- Security and Privacy Model
- Technology Stack
- Repository Structure
- Smart Contract Overview
- Frontend Overview
- Getting Started
- CLI Tasks
- Deployment Checklist
- Limitations
- Future Roadmap
- Docs and References
- License

## Project Summary

HushLink provides a simple, privacy-first flow:

- A sender writes a message.
- The client generates a random ephemeral EVM address (A).
- The message is encrypted with A and stored as ciphertext.
- A is encrypted with Zama FHE and stored on-chain.
- The recipient decrypts A through the FHEVM relayer and then decrypts the message locally.

## Problems Solved

- **On-chain confidentiality**: Plaintext is never stored on-chain, only ciphertext.
- **Key exposure**: The message key (A) is never stored in plaintext and is protected by the FHEVM ACL.
- **Recipient-only access**: The FHEVM access control ensures only recipient and sender can decrypt the key.
- **No external backend**: The contract stores the inbox, eliminating a centralized server.

## Core Advantages

- **End-to-end confidentiality**: Messages are encrypted in the browser before hitting the chain.
- **FHE-protected key**: The key address is stored as an FHE `eaddress`, not a plaintext address.
- **Minimal metadata**: Only sender, recipient, timestamp, and ciphertext are stored.
- **Deterministic flow**: The steps are explicit and auditable, with no hidden services.
- **No browser storage**: No plaintext or key is persisted in local storage.

## How It Works

1. **Compose**: The sender types a message.
2. **Key generation**: The client generates a random EVM address A.
3. **Encrypt**: The message is encrypted with AES-256-GCM using a key derived from `SHA-256(lowercase(A))`.
4. **FHE encrypt**: A is encrypted as `eaddress` using the Zama FHE input flow.
5. **Send**: The contract stores `{ sender, timestamp, ciphertext, encryptedKeyAddress }` in the recipient inbox.
6. **Receive**: The recipient reads the inbox from the contract.
7. **Decrypt key**: The recipient uses the FHEVM relayer to decrypt A.
8. **Decrypt message**: The recipient decrypts the ciphertext locally with A.

Ciphertext format is:

```
v1.<base64(iv)>.<base64(ciphertext)>
```

## Security and Privacy Model

- **On-chain storage**: Ciphertext and encrypted key address only.
- **Off-chain secrets**: Plaintext and key never leave the client in clear form.
- **FHEVM ACL**: The encrypted key is readable only by the sender and recipient.
- **Integrity**: AES-GCM provides integrity checks for ciphertext tampering.

## Technology Stack

- **Smart contracts**: Solidity 0.8.24, Hardhat, hardhat-deploy
- **FHE**: Zama FHEVM (FHE.sol, ZamaConfig), relayer SDK
- **Frontend**: React + Vite
- **Wallet/UI**: RainbowKit + wagmi
- **Reads**: viem
- **Writes**: ethers
- **Crypto**: WebCrypto AES-GCM
- **Styling**: Plain CSS (no Tailwind)

## Repository Structure

```
contracts/             # Solidity contracts
deploy/                # Deployment scripts
deployments/           # Deployed addresses + ABI (per network)
docs/                  # Zama docs used by the project
src/                   # Frontend (React + Vite)
tasks/                 # Hardhat tasks
test/                  # Contract tests
```

## Smart Contract Overview

Contract: `contracts/HushLink.sol`

- **sendMessage(recipient, ciphertext, encryptedKeyAddress, inputProof)**  
  Stores a message and the encrypted key address in the recipient inbox. Grants FHE access to recipient and sender.
- **getInboxCount(user)**  
  Returns the number of messages for a given user.
- **getMessage(user, index)**  
  Returns the message fields for a given user and index.
- **Event**: `MessageSent(sender, recipient, index)`

The contract does not store plaintext and does not rely on `msg.sender` for view functions.

## Frontend Overview

Frontend entry: `src/`

- **No frontend environment variables**: All contract config is compiled into code.
- **Contract config source of truth**: `deployments/sepolia/HushLink.json`
- **Frontend config output**: `src/src/config/contracts.ts`
- **ABI requirement**: The frontend ABI must match the ABI generated by contract deployment.
- **Network**: The UI targets Sepolia; local networks are for contract testing only.

## Getting Started

### Prerequisites

- Node.js 20+
- npm
- Sepolia ETH for deployments
- Infura API key

### Install Dependencies

```bash
npm install
cd src
npm install
```

### Configure Contract Environment (Root Only)

Create `.env` in the repository root:

```
INFURA_API_KEY=your_infura_key
PRIVATE_KEY=your_private_key
ETHERSCAN_API_KEY=optional_for_verification
```

Only `PRIVATE_KEY` is supported for deployments (no mnemonic).

### Compile and Test

```bash
npm run compile
npm run test
```

### Local Node (Contract-Only)

```bash
npx hardhat node
npx hardhat deploy --network localhost
```

### Deploy to Sepolia

```bash
npx hardhat deploy --network sepolia
```

### Sync Frontend ABI + Address

```bash
npx hardhat task:sync-frontend
```

### Run the Frontend

```bash
cd src
npm run dev
```

## CLI Tasks

- **Print contract address**

  ```bash
  npx hardhat --network sepolia task:hushlink:address
  ```

- **Send a message from CLI**

  ```bash
  npx hardhat --network sepolia task:hushlink:send --to 0xRecipient --message "hello"
  ```

The CLI task mirrors the frontend flow: generate an ephemeral address, encrypt the message, FHE-encrypt the address,
then submit `sendMessage`.

## Deployment Checklist

1. `npm run compile`
2. `npm run test`
3. `npx hardhat deploy --network localhost`
4. `npx hardhat deploy --network sepolia`
5. `npx hardhat task:sync-frontend`
6. Launch the frontend and verify inbox/decrypt flow

## Limitations

- The contract stores ciphertext only; message search is limited to client-side scanning.
- The UI targets Sepolia; local networks are for contract testing only.
- There is no off-chain indexing service, so inbox fetches are per-user calls.

## Future Roadmap

- Add pagination and indexing helpers for large inboxes.
- Support attachments by encrypting file blobs with the same ephemeral key.
- Add optional message expiration and delete-by-sender features.
- Expand metadata privacy (e.g., hide sender with optional relays).
- Add multi-device key recovery flows without breaking the FHE model.

## Docs and References

- `docs/zama_llm.md`
- `docs/zama_doc_relayer.md`
- Zama FHEVM documentation: https://docs.zama.ai/fhevm

## License

BSD-3-Clause-Clear. See `LICENSE`.
